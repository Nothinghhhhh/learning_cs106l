# ch2 Types and struct
1. Dynamic vs static typing is independent of being interpreted or compiled; however, many interpreted languages are dynamically typed and many compiled languages are statically typed.
2. `std::pair`
```
std::pair<type1, type2> instance_name{init1, init2};
struct std::pair{
	type1 first;
	type2 second;
};
```
3. `#include` performs a textual inclusion at preprocessing time (it is like pasting the header’s contents at that line), but include guards/`#pragma once` prevent multiple definition problems.
## ch3 Initialization / references / const
1. Copy vs direct initialization: `int a = 1;` (copy init) and `int a(1);` (direct init) both perform type checking; they differ in which constructors/overloads participate.
2. Brace (uniform) initialization: `int a{};` value-initializes to zero and prevents narrowing conversions; works for all object types.
3. Structured bindings:
	`auto make_vals(){ return std::tuple{v1, v2, v3}; }`
	`auto [x, y, z] = make_vals();`
4. A reference is an alias for an existing object.
5. Lvalue references (`T&`) bind to lvalues; const lvalue references (`const T&`) can bind to lvalues and to temporaries (rvalues).
6. Examples: `const int& a = getConst();` is fine; `int& b = getConst();` is ill-formed because a non-const lvalue reference cannot bind to a temporary or to a const object.

## ch4 stream
1. Extraction with `operator>>` skips leading whitespace and stops at the next whitespace (space, `\n`, `\t`), leaving that delimiter in the input buffer. Use `cin.ignore()` (or `ws`) if you need to discard it.
2. `std::getline(stream, dst, delim='\n')` reads up to the delimiter and consumes (discards) it. When mixing `>>` and `getline`, handle the leftover newline before calling `getline`.
3. `std::endl` inserts a newline and flushes the stream (more expensive). `"\n"` inserts a newline without forcing a flush; streams flush automatically when needed (e.g., on buffer flush, on `std::flush`, or when tied to `cout` before `cin`).

## ch5 containers
1. `operator[]` on `vector`/`string` does not do bounds checking; `at()` does (throws on out-of-range) and is slightly slower.
2. `deque` supports efficient push/pop at both ends; it is typically implemented as a sequence of fixed-size blocks managed by a map of pointers.
3. `std::map` stores key–value pairs in an ordered balanced tree (usually red–black). Keys are unique and ordered by a strict weak ordering (by default `operator<`).
4. `std::set` is like `map` without the mapped value (it stores unique keys).
5. `std::unordered_map` stores elements in buckets using hashing. Keys must be hashable and equality-comparable. The load factor is `size / bucket_count`; use `reserve`/`rehash` to manage bucket count and performance.
6. `std::unordered_set` is the `unordered_map` counterpart that stores only keys.
![[5e32b775-344d-48af-8914-8cc8b5b72c01.png]]
## ch6 iterators
1. An iterator abstracts a position within a range; many behave like pointers to elements.
2. Iterator categories:
	- Input: single-pass, readable (e.g., stream iterators).
	- Output: single-pass, writable to the pointed-to position.
	- Forward: multi-pass, readable (and sometimes writable); unordered containers provide forward iterators.
	- Bidirectional: forward and backward (e.g., `map`, `set`).
	- Random access: constant-time jump/offset, indexing, comparison (e.g., `vector`, `deque`).
3. Prefer `++it` to `it++`. Pre-increment can avoid creating a temporary and is never slower for iterators.
